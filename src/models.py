class svm:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'

class knn:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'
    
class decision_tree:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'
    
class random_forest:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'
    
class xgboost:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'
    
class lightgbm:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'
    
class catboost:
    def __init__(self):
        pass

    def train(self, x, y):
        '''
        x: training data
        y: training labels
        '''

    def save(self, filepath):
        print("Saving model to:", filepath)

    def load(self, filepath):
        print("Loading model from:", filepath)

    def evaluate(self, x, y):
        ''''
        x: test data
        y: test labels
        '''
        return "{accuracy:, precision:, recall:, f1-score:}"
    
    def predict(self, input_data):
        print("Predicting with model for input:", input_data)
        return '0 or 1'